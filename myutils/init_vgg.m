function net = init_vgg(scal,init_bias,model_type)
  addpath ../../o2p-release1/external_src/
  DefaultVal('*scal','1');
  DefaultVal('*init_bias','0');
  DefaultVal('*model_type','D');

  switch model_type
    case 'A'
      type = 1;
    case 'B'
      type = 2;
    case 'D'
      type = 3;
    case 'E'
      type = 4;
    otherwise 
      error('wrong model!');
  end
  net.layers = {} ;

  % Block 1
  net.layers{end+1} = struct('name', 'conv1_1', ...
                             'type', 'conv', ...
                             'filters', 0.01/scal * randn(3, 3, 3, 64, 'single'), ...
                             'biases', init_bias*ones(1, 64, 'single'), ...
                             'stride', 1, ...
                             'pad', 1, ...
                             'filtersLearningRate', 1, ...
                             'biasesLearningRate', 2, ...
                             'filtersWeightDecay', 1, ...
                             'biasesWeightDecay', 0) ;
  net.layers{end+1} = struct('name', 'relu1_1', ...
                             'type', 'relu') ;

  if type>1
  net.layers{end+1} = struct('name', 'conv1_2', ...
                             'type', 'conv', ...
                             'filters', 0.01/scal * randn(3, 3, 64, 64, 'single'), ...
                             'biases', init_bias*ones(1, 64, 'single'), ...
                             'stride', 1, ...
                             'pad', 1, ...
                             'filtersLearningRate', 1, ...
                             'biasesLearningRate', 2, ...
                             'filtersWeightDecay', 1, ...
                             'biasesWeightDecay', 0) ;
  net.layers{end+1} = struct('name', 'relu1_2', ...
                             'type', 'relu') ;
  end                   
  net.layers{end+1} = struct('name', 'mpool1', ...
                             'type', 'pool', ...
                             'method', 'max', ...
                             'pool', [2 2], ...
                             'stride', 2, ...
                             'pad', 0) ;
  % Block 2
  net.layers{end+1} = struct('name', 'conv2_1', ...
                             'type', 'conv', ...
                             'filters', 0.01/scal * randn(3, 3, 64, 128, 'single'), ...
                             'biases', init_bias*ones(1, 128, 'single'), ...
                             'stride', 1, ...
                             'pad', 2, ...
                             'filtersLearningRate', 1, ...
                             'biasesLearningRate', 2, ...
                             'filtersWeightDecay', 1, ...
                             'biasesWeightDecay', 0) ;
  net.layers{end+1} = struct('name', 'relu2_1', ...
                             'type', 'relu') ;
  
  if type>1                         
  net.layers{end+1} = struct('name', 'conv2_2', ...
                             'type', 'conv', ...
                             'filters', 0.01/scal * randn(3, 3, 128, 128, 'single'), ...
                             'biases', init_bias*ones(1, 128, 'single'), ...
                             'stride', 1, ...
                             'pad', 2, ...
                             'filtersLearningRate', 1, ...
                             'biasesLearningRate', 2, ...
                             'filtersWeightDecay', 1, ...
                             'biasesWeightDecay', 0) ;
  net.layers{end+1} = struct('name', 'relu2_2', ...
                             'type', 'relu') ;
  end
  
  net.layers{end+1} = struct('name', 'mpool2', ...
                             'type', 'pool', ...
                             'method', 'max', ...
                             'pool', [2 2], ...
                             'stride', 2, ...
                             'pad', 0) ;
    
  % Block 3
  net.layers{end+1} = struct('name', 'conv3_1', ...
                             'type', 'conv', ...
                             'filters', 0.01/scal * randn(3,3,128,256,'single'), ...
                             'biases', init_bias*ones(1,256,'single'), ...
                             'stride', 1, ...
                             'pad', 1, ...
                             'filtersLearningRate', 1, ...
                             'biasesLearningRate', 2, ...
                             'filtersWeightDecay', 1, ...
                             'biasesWeightDecay', 0) ;
  net.layers{end+1} = struct('name', 'conv3_1', ...
                             'type', 'relu') ;

  net.layers{end+1} = struct('name', 'conv3_2', ...
                             'type', 'conv', ...
                             'filters', 0.01/scal * randn(3,3,256,256,'single'), ...
                             'biases', init_bias*ones(1,256,'single'), ...
                             'stride', 1, ...
                             'pad', 1, ...
                             'filtersLearningRate', 1, ...
                             'biasesLearningRate', 2, ...
                             'filtersWeightDecay', 1, ...
                             'biasesWeightDecay', 0) ;
  net.layers{end+1} = struct('name', 'conv3_2', ...
                             'type', 'relu') ;
  
  if type > 2
  net.layers{end+1} = struct('name', 'conv3_3', ...
                             'type', 'conv', ...
                             'filters', 0.01/scal * randn(3,3,256,256,'single'), ...
                             'biases', init_bias*ones(1,256,'single'), ...
                             'stride', 1, ...
                             'pad', 1, ...
                             'filtersLearningRate', 1, ...
                             'biasesLearningRate', 2, ...
                             'filtersWeightDecay', 1, ...
                             'biasesWeightDecay', 0) ;
  net.layers{end+1} = struct('name', 'conv3_3', ...
                             'type', 'relu') ;
  end
  
  if type > 3
  net.layers{end+1} = struct('name', 'conv3_3', ...
                             'type', 'conv', ...
                             'filters', 0.01/scal * randn(3,3,256,256,'single'), ...
                             'biases', init_bias*ones(1,256,'single'), ...
                             'stride', 1, ...
                             'pad', 1, ...
                             'filtersLearningRate', 1, ...
                             'biasesLearningRate', 2, ...
                             'filtersWeightDecay', 1, ...
                             'biasesWeightDecay', 0) ;
  net.layers{end+1} = struct('name', 'conv3_3', ...
                             'type', 'relu') ;
  end
  
  net.layers{end+1} = struct('name', 'mpool3', ...
                             'type', 'pool', ...
                             'method', 'max', ...
                             'pool', [2 2], ...
                             'stride', 2, ...
                             'pad', 0) ;

                           
  % Block 4
  net.layers{end+1} = struct('name', 'conv4_1', ...
                             'type', 'conv', ...
                             'filters', 0.01/scal * randn(3,3,256,512,'single'), ...
                             'biases', init_bias*ones(1,512,'single'), ...
                             'stride', 1, ...
                             'pad', 1, ...
                             'filtersLearningRate', 1, ...
                             'biasesLearningRate', 2, ...
                             'filtersWeightDecay', 1, ...
                             'biasesWeightDecay', 0) ;
  net.layers{end+1} = struct('name', 'conv4_1', ...
                             'type', 'relu') ;

  net.layers{end+1} = struct('name', 'conv4_2', ...
                             'type', 'conv', ...
                             'filters', 0.01/scal * randn(3,3,512,512,'single'), ...
                             'biases', init_bias*ones(1,512,'single'), ...
                             'stride', 1, ...
                             'pad', 1, ...
                             'filtersLearningRate', 1, ...
                             'biasesLearningRate', 2, ...
                             'filtersWeightDecay', 1, ...
                             'biasesWeightDecay', 0) ;
  net.layers{end+1} = struct('name', 'conv3_2', ...
                             'type', 'relu') ;
  
  net.layers{end+1} = struct('name', 'conv4_3', ...
                             'type', 'conv', ...
                             'filters', 0.01/scal * randn(3,3,512,512,'single'), ...
                             'biases', init_bias*ones(1,512,'single'), ...
                             'stride', 1, ...
                             'pad', 1, ...
                             'filtersLearningRate', 1, ...
                             'biasesLearningRate', 2, ...
                             'filtersWeightDecay', 1, ...
                             'biasesWeightDecay', 0) ;
  net.layers{end+1} = struct('name', 'conv4_3', ...
                             'type', 'relu') ;
   
  if type>3
    net.layers{end+1} = struct('name', 'conv4_4', ...
                               'type', 'conv', ...
                               'filters', 0.01/scal * randn(3,3,512,512,'single'), ...
                               'biases', init_bias*ones(1,512,'single'), ...
                               'stride', 1, ...
                               'pad', 1, ...
                               'filtersLearningRate', 1, ...
                               'biasesLearningRate', 2, ...
                               'filtersWeightDecay', 1, ...
                               'biasesWeightDecay', 0) ;
    net.layers{end+1} = struct('name', 'conv4_4', ...
                               'type', 'relu') ;
  end
  net.layers{end+1} = struct('name', 'mpool4', ...
                             'type', 'pool', ...
                             'method', 'max', ...
                             'pool', [2 2], ...
                             'stride', 2, ...
                             'pad', 0) ;
                           
  % Block 5
  net.layers{end+1} = struct('name', 'conv5_1', ...
                             'type', 'conv', ...
                             'filters', 0.01/scal * randn(3,3,512,512,'single'), ...
                             'biases', init_bias*ones(1,512,'single'), ...
                             'stride', 1, ...
                             'pad', 1, ...
                             'filtersLearningRate', 1, ...
                             'biasesLearningRate', 2, ...
                             'filtersWeightDecay', 1, ...
                             'biasesWeightDecay', 0) ;
  net.layers{end+1} = struct('name', 'conv5_1', ...
                             'type', 'relu') ;

  net.layers{end+1} = struct('name', 'conv5_2', ...
                             'type', 'conv', ...
                             'filters', 0.01/scal * randn(3,3,512,512,'single'), ...
                             'biases', init_bias*ones(1,512,'single'), ...
                             'stride', 1, ...
                             'pad', 1, ...
                             'filtersLearningRate', 1, ...
                             'biasesLearningRate', 2, ...
                             'filtersWeightDecay', 1, ...
                             'biasesWeightDecay', 0) ;
  net.layers{end+1} = struct('name', 'conv5_2', ...
                             'type', 'relu') ;
  
  net.layers{end+1} = struct('name', 'conv5_3', ...
                             'type', 'conv', ...
                             'filters', 0.01/scal * randn(3,3,512,512,'single'), ...
                             'biases', init_bias*ones(1,512,'single'), ...
                             'stride', 1, ...
                             'pad', 1, ...
                             'filtersLearningRate', 1, ...
                             'biasesLearningRate', 2, ...
                             'filtersWeightDecay', 1, ...
                             'biasesWeightDecay', 0) ;
  net.layers{end+1} = struct('name', 'conv5_3', ...
                             'type', 'relu') ;
  
  if type>3
    net.layers{end+1} = struct('name', 'conv5_4', ...
                             'type', 'conv', ...
                             'filters', 0.01/scal * randn(3,3,512,512,'single'), ...
                             'biases', init_bias*ones(1,512,'single'), ...
                             'stride', 1, ...
                             'pad', 1, ...
                             'filtersLearningRate', 1, ...
                             'biasesLearningRate', 2, ...
                             'filtersWeightDecay', 1, ...
                             'biasesWeightDecay', 0) ;
    net.layers{end+1} = struct('name', 'conv5_4', ...
                               'type', 'relu') ;
  end
  net.layers{end+1} = struct('name', 'mpool4', ...
                             'type', 'pool', ...
                             'method', 'max', ...
                             'pool', [2 2], ...
                             'stride', 2, ...
                             'pad', 0) ;             
                           
  % Block 6
  net.layers{end+1} = struct('name', 'fc6', ...
                             'type', 'conv', ...
                             'filters', 0.01/scal * randn(7,7,512,4096,'single'),...
                             'biases', init_bias*ones(1,4096,'single'), ...
                             'stride', 1, ...
                             'pad', 0, ...
                             'filtersLearningRate', 1, ...
                             'biasesLearningRate', 2, ...
                             'filtersWeightDecay', 1, ...
                             'biasesWeightDecay', 0) ;
  net.layers{end+1} = struct('name', 'relu6', ...
                             'type', 'relu') ;
  net.layers{end+1} = struct('type', 'dropout', ...
                             'rate', 0.5) ;

  % Block 7
  net.layers{end+1} = struct('name', 'fc7', ...
                             'type', 'conv', ...
                             'filters', 0.01/scal * randn(1,1,4096,4096,'single'),...
                             'biases', init_bias*ones(1,4096,'single'), ...
                             'stride', 1, ...
                             'pad', 0, ...
                             'filtersLearningRate', 1, ...
                             'biasesLearningRate', 2, ...
                             'filtersWeightDecay', 1, ...
                             'biasesWeightDecay', 0) ;
  net.layers{end+1} = struct('name', 'relu7', ...
                             'type', 'relu') ;
  net.layers{end+1} = struct('type', 'dropout', ...
                             'rate', 0.5) ;

  % Block 8
  net.layers{end+1} = struct('name', 'fc8', ...
                             'type', 'conv', ...
                             'filters', 0.01/scal * randn(1,1,4096,1000,'single'), ...
                             'biases', zeros(1, 1000, 'single'), ...
                             'stride', 1, ...
                             'pad', 0, ...
                             'filtersLearningRate', 1, ...
                             'biasesLearningRate', 2, ...
                             'filtersWeightDecay', 1, ...
                             'biasesWeightDecay', 0) ;

  % Block 9
  net.layers{end+1} = struct('name','sftm','type', 'softmaxloss') ;
end